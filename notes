Possible options for adding/sorting:

  1.) No matter how/where the person adds a model, the collection re-sorts based on the sort index. This means we can use add, unshift, push, or add(at), and it will be ignored. Instead, it will add it as usual, but then re-sort. For new notes w/ -1 sort index, they are assigned an index, then it sorts.

    Client impact: Seperate add operations lose meaning. Performance drop.

  2.) Only use add(sortIndex) for models with sort indeces, thus never necessitating a sort except on initialization. For new models, add will add to the end, and sort index is still assigned, same as option 1. This means we can use add, unshift, push etc, but their state will be lost on reload. Don't need to sort at all (except on init), because we can just make sortIndex mimic the collection index, since that's always correct until page reload. Having this attribute simply allows preservation. Maybe that's what I should do.

    Client impact: Must make conscious effort to only use add(at: sortIndex). Other operation states are lost on reload. Performance increase.

  Considerations:
    Collection index is determined by when they were created, more or less. We need a seperate attribute called sortIndex to preserve the user-created state of the collection. We can re-order the collection in a single session and the collection indeces change, and can re-render all we want, but they are not preserved on reload. Sync does not save the order of the collection, only the attributes of the models.

    Therefore, sortIndex is an additional property that can be preserved at all times. To the client, it will look like the sort index always matches the collection index. However, what's happening is that the collection index is being made to realign with the sort index after add/remove operations.

    In both options, we need to shift up or down when we insert, so the sort index matches the collection index.




// the array-less define call makes it so you can require stuff.
// if you put in an array and put require as a dep, it get's screwy.
define(function(require){
  var Backbone = require('backbone'),
    literallyAnything = require('handlebars');
});

// example main.js
// jquery does not be to individually loaded. You can simply use $
requirejs.config({
  baseUrl: '../app',
  paths: {
    require: 'lib/require',
    jquery: 'lib/jquery',
    underscore: 'lib/underscore',
    backbone: 'lib/backbone',
    handlebars: 'lib/handlebars',
    bootstrap: 'lib/bootstrap'
  },
  shim: {
    'handlebars': {
      'exports': 'Handlebars'
    },
    'bootstrap': {
      deps: ['jquery']
    }
  }
});

require(['bt-app']);



// Bootstrap in a few notes (bt-app.js)

var note1 = new NoteModel({
  x: 100,
  y: 100,
  width: 300,
  height: 200,
  color: 'crimson',
  content: 'The first note'
});
var note2 = new NoteModel({
  x: 500,
  y: 100,
  width: 200,
  height: 300,
  color: 'skyblue',
  content: 'The second note'
});

notesCollection.add([
  note1,
  note2
]);

notesCollection.sync('create', note1, {success: function(){console.log('success')}});
notesCollection.sync('create', note2, {success: function(){console.log('success')}});

/*
  All 3 of these do slightly different things:
*/

//1 -> triggers a destroy event
noteModel.destroy({
  success: function() {
    console.log('destroyed model');
  },
  failure: function() {
    console.log('failed to destroy model');
  }
})

//2 -> doesn't destroy it
this.collection.remove(noteModel);

//3 -> deletes, but doesn't cause event. basically, manually calling stuff done in destroy()
self.collection.sync('update', noteModel, {
  success: function(){
    console.log('saved position');
  },
  failure: function(){
    console.log('failed to save position');
  }
});